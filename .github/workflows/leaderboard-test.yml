name: Update Loose Goose Leaderboard

on:
  schedule:
    - cron: '0 * * * *'  # Runs every hour at the start of the hour
  workflow_dispatch:  # Allows manual triggering

jobs:
  update-leaderboard:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Update Leaderboard
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const issueNumber = 1;
          const REPOS = [
            'taniashiba/tania-tests',
          ];
          const calculatePoints = (labels) => {
            return 10;
          };

          const fetchRecentPRs = async (repo) => {
            try {
              console.log(`Fetching recent PRs for ${repo}`);
              const [repoOwner, repoName] = repo.split('/');
              
              const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
              
              const { data: prs } = await github.rest.pulls.list({
                owner: repoOwner,
                repo: repoName,
                state: 'closed',
                sort: 'updated',
                direction: 'desc',
                per_page: 100
              });
              
              console.log(`Fetched ${prs.length} PRs for ${repo}`);
              
              const loosegoosePRs = prs.filter(pr => {
                const isMerged = !!pr.merged_at;
                const isRecent = new Date(pr.merged_at) > new Date(thirtyDaysAgo);
                const isLoosegoose = pr.labels.some(label => label.name.toLowerCase() === 'loosegoose');
                return isMerged && isRecent && isLoosegoose;
              }).map(pr => ({
                user: pr.user.login,
                points: calculatePoints(pr.labels),
                repo: repo,
                prNumber: pr.number,
                prTitle: pr.title,
              }));
              return loosegoosePRs;
            } catch (error) {
              console.error(`Error fetching PRs for ${repo}: ${error.message}`);
              return [];
            }
          };

          const generateLeaderboard = async () => {
            try {
              const allPRs = await Promise.all(REPOS.map(fetchRecentPRs));
              const flatPRs = allPRs.flat();
              const leaderboard = flatPRs.reduce((acc, pr) => {
                if (!acc[pr.user]) acc[pr.user] = { points: 0, prs: 0 };
                acc[pr.user].points += pr.points;
                acc[pr.user].prs += 1;
                return acc;
              }, {});
              
              return Object.entries(leaderboard)
                .sort(([, a], [, b]) => b.points - a.points)
                .map(([username, data], index) => ({ 
                  rank: index + 1, 
                  username, 
                  points: data.points, 
                  prs: data.prs 
                }));
            } catch (error) {
              console.error(`Error generating leaderboard: ${error.message}`);
              return [];
            }
          };

          const updateIssue = async (leaderboardData) => {
            try {
              const rows = leaderboardData.map(entry => 
                `| ${entry.rank} | @${entry.username} | ${entry.points} | ${entry.prs} |`
              ).join('\n');

              const issueBody = [
                '# ğŸ† Loose Goose November 2024 Leaderboard ğŸ†',
                '',
                '### ğŸŒŸ **Current Rankings:**',
                '| Rank | Contributor | Points | PRs |',
                '|------|-------------|--------|-----|',
                rows,
                '',
                `Last updated: ${new Date().toUTCString()}`
              ].join('\n');

              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                body: issueBody
              });
              console.log("Issue updated successfully!");
            } catch (error) {
              throw new Error(`Failed to update issue: ${error.message}`);
            }
          };

          // Main execution
          const leaderboardData = await generateLeaderboard();
          
          if (leaderboardData.length > 0) {
            await updateIssue(leaderboardData);
          } else {
            console.log("No leaderboard data to update.");
            const emptyIssueBody = [
              '# ğŸ† Loose Goose November 2024 Leaderboard ğŸ†',
              '',
              'No qualifying PRs found at this time. Check back soon!',
              '',
              `Last updated: ${new Date().toUTCString()}`
            ].join('\n');

            await github.rest.issues.update({
              owner,
              repo,
              issue_number: issueNumber,
              body: emptyIssueBody
            });
            console.log("Updated issue with empty leaderboard message.");
          }
